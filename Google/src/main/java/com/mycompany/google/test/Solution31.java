/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.mycompany.google.test;


/**
 *
 * @author selyc
 */

public class Solution31 {
    
    public static void main(String[] arg){
        
        
        /*
        int[][] params={{0, 1, 0, 0, 0, 1}, {4, 0, 0, 3, 2, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}};
        int[] ret=Solution.solution(params);
        
        System.out.println("Question Matrix");
        printMatrix(params);
        
        System.out.println("Answer");
        printArray(ret);*/
        /*
        int[][] params=new int[][]{{0, 2, 1, 0, 0}, {0, 0, 0, 3, 4}, {0, 0, 0, 0, 0}, {0, 0, 0, 0,0}, {0, 0, 0, 0, 0}};
        
        int[]ret=Solution.solution(params);
        
        System.out.println("Question Matrix");
        printMatrix(params);
        
        System.out.println("Answer");
        printArray(ret); */
        
        /*
        int[][] params=
        {
            {0, 86, 61, 189, 0, 18, 12, 33, 66, 39}, 
            {0, 0, 2, 0, 0, 1, 0, 0, 0, 0}, 
            {15, 187, 0, 0, 18, 23, 0, 0, 0, 0}, 
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };*/
        /*
        int[][] params=
        {
            {1, 2, 3, 0, 0, 0}, 
            {4, 5, 6, 0, 0, 0}, 
            {7, 8, 9, 1, 0, 0}, 
            {0, 0, 0, 0, 1, 2}, 
            {0, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 0, 0, 0}
        };*/
        
        /*
        int[][] params=
        {
            {0, 0, 12, 0, 15, 0, 0, 0, 1, 8}, 
            {0, 0, 60, 0, 0, 7, 13, 0, 0, 0}, 
            {0, 15, 0, 8, 7, 0, 0, 1, 9, 0}, 
            {23, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
            {37, 35, 0, 0, 0, 0, 3, 21, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };*/
        
        /*
        int[][] params=
        {
            {0, 7, 0, 17, 0, 1, 0, 5, 0, 2}, 
            {0, 0, 29, 0, 28, 0, 3, 0, 16, 0}, 
            {0, 3, 0, 0, 0, 1, 0, 0, 0, 0}, 
            {48, 0, 3, 0, 0, 0, 17, 0, 0, 0}, 
            {0, 6, 0, 0, 0, 1, 0, 0, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };*/
        
        /*
        int[][] params=
        {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };*/
        
        /*
        int[][] params=
        {
            {1, 1, 1, 0, 1, 0, 1, 0, 1, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {1, 0, 1, 1, 1, 0, 1, 0, 1, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {1, 0, 1, 0, 1, 1, 1, 0, 1, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 1, 0, 1, 0, 1, 1, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 1, 0, 1, 0, 1, 0, 1, 1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };*/
        
        
        int[][] params=
        {
            {0, 0, 0, 0, 3, 5, 0, 0, 0, 2}, 
            {0, 0, 4, 0, 0, 0, 1, 0, 0, 0}, 
            {0, 0, 0, 4, 4, 0, 0, 0, 1, 1}, 
            {13, 0, 0, 0, 0, 0, 2, 0, 0, 0}, 
            {0, 1, 8, 7, 0, 0, 0, 1, 3, 0}, 
            {1, 7, 0, 0, 0, 0, 0, 2, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        
        /*
        int[][] params=
        {
            {0}
        };*/
        
        int[] ret=Solution31.solution(params);
        
        System.out.println("Question Matrix");
        //printMatrix(params);
        
        System.out.println("Answer");
        //printArray(ret);

        
    }
        
    
    public static int[] solution(int[][] m) {
        // Your code here                
        
        //Finding Number of Stable State
        int[] sum= new int[10];         
        int stableCount=0;
        for(int i=0;i<m.length;++i){
            for(int j=0;j<m[i].length;++j){
                sum[i]+=m[i][j];
            }
            if(sum[i]==0){
                ++stableCount;
            }
        }
        
        if(sum[0]==0||m.length==1){//If first state is absorbing, it wont go from there
            int[] ret= new int[m.length+1];
            ret[0]=1;
            ret[m.length]=1;
            return ret;
        }        
        
        
        //R Fraction Matrix        
        Fraction[][] rFMat= new Fraction[m.length-stableCount][stableCount];
        int r=0;        
        int c=0;
        for(int i=0;i<m.length;++i){
            if(sum[i]>0){
                for(int j=0;j<m[i].length;++j){
                    if(sum[j]==0){
                        rFMat[r][c]=new Fraction(m[i][j],sum[i]);
                        ++c;                        
                    }
                }
                c=0;
                ++r;
            }
        }
        
        //Q Fraction Matrix
        Fraction[][] qFMat= new Fraction[m.length-stableCount][m.length-stableCount];
        r=0;        
        c=0;
        for(int i=0;i<m.length;++i){
            if(sum[i]>0){
                for(int j=0;j<m[i].length;++j){
                    if(sum[j]>0){                        
                        qFMat[r][c]= new Fraction(m[i][j],sum[i]);                        
                        ++c;                        
                    }
                }
                c=0;
                ++r;
            }
        }
        
        //Identity Matrix
        Fraction[][] iFMat= new Fraction[qFMat.length][qFMat[0].length];
        for(int i=0;i<qFMat.length;++i){
            for(int j=0; j<qFMat[0].length;++j){
                if(i==j){
                    iFMat[i][j]= new Fraction(1,1); 
                }else{
                    iFMat[i][j]= new Fraction(0,1); 
                }
            }
        }
                             
        //I-Q
        Fraction[][] imqFMat= Fraction.matrixSubstract(iFMat, qFMat);
                        
        //matrix Inverse
        Fraction[][] fFMat=Fraction.invert(imqFMat);                             
        
        Fraction[][] frFMat = Fraction.matrixMultiply(fFMat, rFMat);        
        
        //Finding LCM
        //Get All Denominators
        double[] lArr = new double[frFMat[0].length];
        for(int i=0;i<frFMat[0].length;++i){
            lArr[i]=frFMat[0][i].getDenominator();
        }
        
        double lcm=leastcm(lArr);
        
        int[] result = new int[lArr.length+1];
        for(int i=0;i<frFMat[0].length;++i){
            int n=(int)frFMat[0][i].getNumerator();
            int d=(int)frFMat[0][i].getDenominator();
            result[i]=(int)(n*(lcm/d));
        }
        result[result.length-1]=(int)lcm;
        
                
        return result;
    }
    
    private static double leastcm(double a[]){
        
        //Find th largest number
        double lcm=0;
        for(int i=0;i<a.length;++i){
            if(lcm<Math.abs(a[i])){
                lcm=a[i];
            }
        }
        while(true){
            boolean match=true;
            for(int i=0;i<a.length;++i){
                if(lcm%a[i]!=0){
                    lcm+=lcm;
                    i=0;
                }
            }
            if(true){
                break;
            }
        }        
        
        return lcm;
    }
            
    static class Fraction{
        private double numerator=0;
        private double denominator=1;
        
        public Fraction(){
            numerator=0;
            denominator=1;
        }
        public Fraction(double n, double d){
            numerator=n;
            denominator=d;            
            reduce();
        }

        public double getNumerator() {
            return numerator;
        }

        public void setNumerator(double numberator) {
            this.numerator = numberator;
            reduce();
        }

        public double getDenominator() {
            return denominator;
        }

        public void setDenominator(double denominator) {
            this.denominator = denominator;
            reduce();
            
        }
        
        private void reduce(){
            //Fraction Reduction
            if(numerator==0){
                denominator=1;
            }
            double smallest=Math.abs(numerator)>Math.abs(denominator)?Math.abs(denominator):Math.abs(numerator);            
            for(int i=2;i<=smallest;++i){
                if(numerator%i==0 && denominator%i==0){
                    numerator/=i;
                    denominator/=i;
                    i=2;
                    smallest=numerator>denominator?denominator:numerator;
                    smallest=smallest/2;
                }
            }
            
            //Update Sign
            if(denominator<0){
                numerator*=-1;
                denominator*=-1;
            }
        }
        
        public static Fraction[][] matrixSubstract(Fraction[][] x, Fraction[][] y){
            
            Fraction[][] z= new Fraction[x.length][x[0].length];
            
            for(int i=0;i<x.length;++i){
                for(int j=0;j<x[0].length;++j){                    
                    z[i][j]= new Fraction(0,1);
                    z[i][j].denominator=x[i][j].denominator*y[i][j].denominator;
                    z[i][j].numerator=(x[i][j].numerator*y[i][j].denominator)-(y[i][j].numerator*x[i][j].denominator);
                }
            }
            
            return z;
            
        }
        
        public static Fraction[][] matrixMultiply(Fraction[][] x, Fraction[][] y){
            
            Fraction[][] z= new Fraction[x.length][y[0].length];
            
            for(int i=0;i<x.length;++i){                
                for(int j=0;j<y[0].length;++j){
                    z[i][j]=new Fraction(0,1);                    
                    for(int k=0;k<x.length;++k){
                        Fraction mul=Fraction.fracMultiply(x[i][k], y[k][j]);
                        z[i][j]=Fraction.fracAdd(z[i][j], mul);                        
                    }                    
                }
            }
            
            return z;
            
        }
        
        public static Fraction fracAdd(Fraction x, Fraction y){
            
            Fraction z= new Fraction();
            
            double xn=x.getNumerator();
            double xd=x.getDenominator();
            double yn=y.getNumerator();
            double yd=y.getDenominator();
            
            double n= (xn*yd)+(yn*xd);
            double d= xd*yd;
            
            z.setNumerator(n);
            z.setDenominator(d);
            z.reduce();
            
            return z;
            
        }
        
        public static Fraction fracSubtract(Fraction x, Fraction y){
            
            Fraction z= new Fraction();
            
            double xn=x.getNumerator();
            double xd=x.getDenominator();
            double yn=y.getNumerator();
            double yd=y.getDenominator();
            
            double n= (xn*yd)-(yn*xd);
            double d= xd*yd;
            
            z.setNumerator(n);
            z.setDenominator(d);
            z.reduce();
            
            return z;
            
        }
             
        public static Fraction fracMultiply(Fraction x, Fraction y){
            
            Fraction z= new Fraction();
            z.setNumerator(x.getNumerator()*y.getNumerator());
            z.setDenominator(x.getDenominator()*y.getDenominator());
            
            z.reduce();
            return z;
            
        }
                          
        public static Fraction[][] invert(Fraction[][] a){
            
            int n = a.length;
            Fraction x[][] = new Fraction[n][n];
            Fraction b[][] = new Fraction[n][n];
            int index[] = new int[n];
            
            //Initialise
             for (int i=0; i<n; ++i){
                for(int j=0;j<n;++j){                    
                    x[i][j]= new Fraction();
                    b[i][j]= new Fraction();
                    if(i==j){
                        b[i][j] = new Fraction(1,1);
                    }else{
                        b[i][j] = new Fraction(0,1);
                    }
                }
             }
             
           
            // Transform the matrix into an upper triangle
            gaussian(a, index);
        
             
             // Update the matrix b[i][j] with the ratios stored
            for (int i=0; i<n-1; ++i){
                for (int j=i+1; j<n; ++j){
                    for (int k=0; k<n; ++k){    
                        
                        b[index[j]][k]= Fraction.fracSubtract(b[index[j]][k], Fraction.fracMultiply(a[index[j]][i], b[index[i]][k])) ;

                    }
                }
            }
            // Perform backward substitutions
            for (int i=0; i<n; ++i) 
            {
                double ni=b[index[n-1]][i].getNumerator();
                double di=b[index[n-1]][i].getDenominator();
                double nj=a[index[n-1]][n-1].getNumerator();
                double dj=a[index[n-1]][n-1].getDenominator();
                x[n-1][i] = new Fraction(ni*dj,nj*di);
                for (int j=n-2; j>=0; --j) 
                {
                    x[j][i] = b[index[j]][i];
                    for (int k=j+1; k<n; ++k) 
                    {                        
                        x[j][i] = Fraction.fracSubtract(x[j][i],Fraction.fracMultiply(a[index[j]][k], x[k][i]));
                    }
                    double nx=x[j][i].getNumerator();
                    double dx=x[j][i].getDenominator();
                    double na=a[index[j]][j].getNumerator();
                    double da=a[index[j]][j].getDenominator();
                    x[j][i] = new Fraction(nx*da,na*dx);
                }
            }
            return x;
        }
        
        public static void gaussian(Fraction a[][], int index[]) {
            int n = index.length;
            double c[] =new double[n];
             // Initialize the index
            for (int i=0; i<n; ++i){ 
                index[i] = i;
            }
                        
            // Find the rescaling factors, one from each row
            for (int i=0; i<n; ++i) 
            {
                double c1 = 0;
                for (int j=0; j<n; ++j) 
                {
                    double nn=Math.abs(a[i][j].getNumerator());
                    double dd=Math.abs(a[i][j].getDenominator());
                    double c0 = nn/dd;                    
                    if (c0 > c1) c1 = c0;
                }
                c[i] = c1;
            }           
        
            // Search the pivoting element from each column
            int k = 0;
            for (int j=0; j<n-1; ++j) 
            {
                double pi1 = 0;
                for (int i=j; i<n; ++i) 
                {
                    double num=Math.abs(a[i][j].getNumerator());
                    double den=Math.abs(a[i][j].getDenominator());
                    double pi0 = num/den;                    
                    pi0 /= c[index[i]];
                    if (pi0 > pi1) 
                    {
                        pi1 = pi0;
                        k = i;
                    }
                }
                // Interchange rows according to the pivoting order
                int itmp = index[j];
                index[j] = index[k];
                index[k] = itmp;
                for (int i=j+1; i<n; ++i)   
                {
                    double ni=a[index[i]][j].getNumerator();
                    double di=a[index[i]][j].getDenominator();
                    double nj=a[index[j]][j].getNumerator();
                    double dj=a[index[j]][j].getDenominator();
                    Fraction pj = new Fraction(ni*dj,nj*di);

                    // Record pivoting ratios below the diagonal
                    a[index[i]][j] = pj;

                    // Modify other elements accordingly
                    for (int l=j+1; l<n; ++l){
                        a[index[i]][l] = Fraction.fracSubtract(a[index[i]][l], Fraction.fracMultiply(pj, a[index[j]][l]));
                    }
                }
            }
            
        }
        
        public static Fraction[][] matrixInverse(Fraction[][] x){            
            
            //Determinant
            Fraction determinant= new Fraction();
            //Step 1: Matrix of Minors & Step 2: Matrix of Cofactors
            Fraction[][] minorCo = new Fraction[x.length][x.length];
            if(x.length==2){//For 2x2 Matrix                
                minorCo[0][0]= new Fraction(x[1][1].getNumerator(), x[1][1].getDenominator());
                minorCo[0][1]= new Fraction(x[1][0].getNumerator()*-1, x[1][0].getDenominator());
                minorCo[1][0]= new Fraction(x[0][1].getNumerator()*-1, x[0][1].getDenominator());
                minorCo[1][1]= new Fraction(x[0][0].getNumerator(), x[0][0].getDenominator());
                //determinant for 2x2
                determinant= Fraction.fracSubtract(Fraction.fracMultiply(minorCo[0][0], minorCo[1][1]), Fraction.fracMultiply(minorCo[0][1], minorCo[1][0]));                 
            }else{
                for(int i=0;i<x.length;++i){
                    for(int j=0;j<x.length;++j){                        
                        minorCo[i][j]=Fraction.findDeterminant(Fraction.getExMatrix(x, i, j));
                        
                        int sign=(int)Math.pow(-1,i+j);
                        minorCo[i][j].setNumerator(minorCo[i][j].getNumerator()*sign);                        
                    }
                }
                //Finding the Determinant of Whole Matrix
                determinant=Fraction.findDeterminant(x);
            }
            
            
            //Step 3: Adjugate (also called Adjoint)
            Fraction[][] adj = new Fraction[x.length][x.length];
            for(int i=0;i<x.length;++i){
                for(int j=0;j<x.length;++j){
                    adj[i][j]=minorCo[j][i];
                }
            }
            
            //Step 4: Multiply by 1/Determinant
            Fraction[][] inv = new Fraction[x.length][x.length];
            double n=determinant.getNumerator();
            double d=determinant.getDenominator();
            Fraction indet= new Fraction(d,n);
            for(int i=0;i<x.length;++i){
                for(int j=0;j<x.length;++j){
                    inv[i][j]=Fraction.fracMultiply(indet, adj[i][j]);
                }
            }
            
            return inv;
            
        }
        
        public static Fraction findDeterminant(Fraction[][] x){
            
            if(x.length==2){
                Fraction ad=Fraction.fracMultiply(x[0][0],x[1][1]);
                Fraction bc=Fraction.fracMultiply(x[1][0],x[0][1]);                                
                return Fraction.fracSubtract(ad, bc);
            }else{
                //Laplace Expansion                
                int l=(x.length*2)-1;
                Fraction[][] exM =new Fraction[x.length][l];
                //Fill the expansion matrix
                for(int i=0;i<x.length;++i){
                    for(int j=0;j<x.length;++j){
                        exM[i][j]=x[i][j];
                    }
                }
                //Added columns
                for(int i=0;i<x.length;++i){
                    for(int j=0;j<x.length-1;++j){
                        int jj=x.length+j;
                        exM[i][jj]=x[i][j];
                    }
                }
                
                
                Fraction a = new Fraction(0,1);//For addition
                for(int k=0;k<x.length;++k){
                    
                    int ro=0;
                    int co=k;
                    Fraction aa = new Fraction(1,1);//for multiply
                    while(ro<x.length){                                                
                        aa=Fraction.fracMultiply(aa, exM[ro][co]);                        
                        
                        ++ro;
                        ++co;
                    }
                    a=Fraction.fracAdd(a, aa);
                                        
                }                
                Fraction b = new Fraction(0,1);//For addition
                for(int k=0;k<x.length;++k){
                    
                    int ro=x.length-1;
                    int co=k;
                    Fraction bb = new Fraction(1,1);//for multiply
                    while(ro>=0){                                                
                        bb=Fraction.fracMultiply(bb, exM[ro][co]);                        
                        
                        --ro;
                        ++co;
                    }
                    b=Fraction.fracAdd(b, bb);                                        
                }
                
                Fraction det = Fraction.fracSubtract(a, b);
                
                return det;                
            }
        }
        
        public static Fraction[][] getExMatrix(Fraction x[][], int ro, int col){
            Fraction res[][]= new Fraction[x.length-1][x.length-1];
            int ii=0;
            int jj=0;
            for(int i=0;i<x.length;++i){
                if(i!=ro){
                    for(int j=0;j<x.length;++j){
                        if(j!=col){
                            double n=x[i][j].getNumerator();
                            double d=x[i][j].getDenominator();
                            res[ii][jj]=new Fraction(n,d);
                            ++jj;
                        }
                    }
                    jj=0;
                    ++ii;
                }
            }
            return res;
        }
        
    }
    
    
}